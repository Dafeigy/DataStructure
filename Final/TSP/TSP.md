## 数学表述

二维平面上有一由$N$个顶点组成的连通图$G$，其顶点集为$V=\{1,2,\dots,N\}$。记顶点间距离矩阵为$D=[d_{ij}]_{N\times N}$，其中$c_{ij}\geq0,c_{ii}=\infty,i,j\in V$。引入决策变量$x_{ij}$，其表示从点$i$至$j$是否存在一条链路，若有则$x_{ij}=1$，否则为0。引入时间权重$s_{ij}\in\{1,\frac{1}{k}\},k>1,i\neq j$，用于表示点$i$至$j$的权重，定义$w\in(0,1)$为比例约束系数，则问题转换为：
$$
\begin{aligned}
&\min z=\sum_{i=1}^N\sum_{j=1}^Nc_{ij}x_{ij}s_{ij}\\
&s.t.\quad \begin{cases}
\sum_{j=1}^{N}x_{ij}=1\\
\sum_{i=1}^{N}x_{ij}=1\\
\sum_{i,j\in S}x_{ij}\leq|S|-1,\forall S\subseteq V,1<|S|<N\\
x_{i,j}\in\{0,1\}\\
s_{i,j}\in\{1,\frac{1}{k}\}\\
\log_k(\prod s_{ij})\leq {w N}
\end{cases}
\end{aligned}
$$
[1] André Langevin, Soumis F, Desrosiers J. Classification of travelling salesman problem formulations[J]. Operations Research Letters, 1990, 9(2):127-132.

其中，

## 解题思路

### 问题拆解

问题的约束条件较多，且如果使用搜索的方式进行求解那么复杂度将会是$O(N!)$，不利于大规模的问题求解，因此先将问题简化。

注意到$s_{ij}$的取值与$c_{ij}$无关，即他们的取值是独立的，而$c_{ij}$的取值与$x_{ij}$有关，因次问题可拆解为：
$$
\begin{aligned}
&\min z=\sum_{i=1}^N\sum_{j=1}^Nc_{ij}x_{ij}\\
&s.t.\quad \begin{cases}
\sum_{j=1}^{N}x_{ij}=1\\
\sum_{i=1}^{N}x_{ij}=1\\
\sum_{i,j\in S}x_{ij}\leq|S|-1,\forall S\subseteq V,1<|S|<N\\
x_{ij}\in\{0,1\}\\
\end{cases}
\end{aligned}
$$
以及根据上式的解确定的$c_{ij}\in\mathbb S$得到的$s_{ij}$的分配问题：
$$
\begin{aligned}
&\min z=\sum_{i=1}^N\sum_{j=1}^Nc_{ij}s_{ij}\\
&s.t.\quad \begin{cases}
c_{ij}\in\mathbb S\\
s_{ij}\in\{1,\frac{1}{k}\}\\
\log_k(\prod s_{ij})\leq {w N}
\end{cases}
\end{aligned}
$$
第二个子问题的求解非常简单，只需要对得到的解$c_{ij}\in \mathbb S$进行降序排序，并将最大的前$w_nN$个取值为$1/k$即可，难点在于第一个子问题的求解。

### 子问题一的求解

我原本打算使用动态规划进行求解，思路如下：记$i$为当前节点，$S'$为还没遍历的节点，$\varepsilon(i,S)$表示从第$i$个节点起，经历$S'$的所有的点并到达终点的最短路径长度。则有状态转移方程：
$$
\varepsilon(i,S')=\min(d_{{ij},j\in	S'})+\varepsilon(j,S_{/j})
$$
其中，$S'_{/j}$为剔除了点$j$的$S'$集合，随后进行回溯即可直至所有的点都被遍历完。这个方法经过测试，只能在$N$比较小的情况下（不大于20）有最优解，并且迭代时间会越发增多，不利于大规模的场景下求解，因此改用遗传算法进行求解。遗传算法是是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。该算法以一种群体中的所有个体为对象，并利用随机化技术指导对一个被编码的参数空间进行高效搜索。其中，选择、交叉和变异构成了遗传算法的遗传操作；参数编码、初始群体的设定、适应度函数的设计、遗传操作设计、控制参数设定五个要素组成了遗传算法的核心内容https://blog.csdn.net/qq_50313560/article/details/124814551N。

在这个问题的情境下，城市的编号进行排列时有$N!$中排列，将排列作为遗传算法中个体的基因编码，适应度函数设计为:
$$
f(s)=\frac{1}{\sum_{i=1}^{N-1}d_{i,i+1}}
$$

此处的适应度函数值越大，证明改个体所代表的方案性能更优。

## 子问题二的求解

子问题二是一个分配问题。只需要对子问题已得到的解计算相邻两点的距离以及出发点和最后一个点的距离进行升序排序，并将升序排序结果的后$wN$个使用自行车即可得到最短时间遍历全部节点的方案。

## 算法表述

算法的伪代码如下。

## 性能分析

在本题中，遗传算法的性能主要与变异概率、种群选择方法、迭代轮数、种群数量以及问题的规模有关。遗传算法能保障随着迭代的进行目标函数可以朝期望的方向进行收敛，但是收敛的速度、性能与种群选择方法、迭代轮数以及问题的规模有关。

遗传算法的计算量集中于每个个体的自适应函数的计算，在本题中为$O(NG)$，其中N为问题规模，G为种群数量。遗传算法的迭代过程选择的个体是通过适应度函数值进行比较择优选取种群的最优个体进入下一轮迭代，没有利用到适应度函数值的梯度信息或一阶、高阶导数信息，因此不能充分保障迭代的适应度函数的收敛方向的正确性，即有可能会落入局部最优解中，而变异操作是通过引入一定的噪声引导适应度函数收敛过程跳出最优解，因此，在问题规模较大且在迭代后期，应该以更大的变异概率对种群进行处理以跳出局部最优的陷阱；同时，随着问题规模的增大，固定的参数可能不能取得更优的解，因此需要更改迭代的轮数、种群的数量以获得更优的解。
